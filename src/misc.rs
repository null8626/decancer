use crate::parser::Parser;

const NUMERICAL: [u16; 8] = [
  0x2000,
  0x24EA,
  0xDFCE,
  0xDFEC,
  0xDFF6,
  0xDFD8,
  0xFF10,
  0x2070
];

const MISC: [(&'static [u8], &'static [u16]); 73] = [
  (&[0x30], &[0xDFE2]), // "0"
  (&[0x31], &[0x00B9, 0xDFE3]), // "1"
  (&[0x32], &[0x00B2, 0x03E9, 0x14BF, 0xA645, 0xA6EF, 0xA75B, 0xDFE4]), // "2"
  (&[0x33], &[0x00B3, 0x018E, 0x01BA, 0x01EF, 0x0292, 0x0293, 0x0437, 0x044D, 0x0499, 0x04DF, 0x04E1, 0x04ED, 0x1D08, 0x1D23, 0x1D32, 0x1D4C, 0x2CCD, 0xA76B, 0xDF3B, 0xDFE5]), // "3"
  (&[0x34], &[0xAB9E, 0xDFE6]), // "4"
  (&[0x35], &[0x01BD, 0xDFE7]), // "5"
  (&[0x36], &[0x2CD3, 0xABBE, 0xDFE8]), // "6"
  (&[0x37], &[0x2138, 0xDFE9]), // "7"
  (&[0x38], &[0x09EA, 0x0A6A, 0x0B03]), // "8"
  (&[0x39], &[0x09ED, 0x0A67, 0x0B68, 0x0D6D, 0x2CCB, 0xA76F, 0xDEDD, 0xDF17, 0xDF8B, 0xDFC5, 0xDFEA]), // "9"
  (&[0x61], &[0x039B]), // "a"
  (&[0x64], &[0x00D0]), // "d"
  (&[0x65], &[0x03A3]), // "e"
  (&[0x68], &[0x0389]), // "h"
  (&[0x61, 0x61], &[0xA733]), // "aa"
  (&[0x61, 0x65], &[0x00E6, 0x1D02, 0x01E3, 0x01FD]), // "ae"
  (&[0x61, 0x6F], &[0x1D14, 0xA735]), // "ao"
  (&[0x61, 0x75], &[0xA737]), // "au"
  (&[0x76, 0x79], &[0xA761]), // "vy"
  (&[0x74, 0x68], &[0x1D7A]), // "th"
  (&[0x75, 0x65], &[0x1D6B]), // "ue"
  (&[0x6F, 0x65], &[0x0153]), // "oe"
  (&[0x64, 0x62], &[0x0238]), // "db"
  (&[0x61, 0x73], &[0x214D]), // "as"
  (&[0x6C, 0x62], &[0x2114]), // "lb"
  (&[0x6E, 0x6F], &[0x2116]), // "no"
  (&[0x70, 0x78], &[0x211E]), // "px"
  (&[0x73, 0x6D], &[0x2120]), // "sm"
  (&[0x74, 0x65, 0x6C], &[0x2121]), // "tel"
  (&[0x74, 0x6D], &[0x2122]), // "tm"
  (&[0x64, 0x7A], &[0x01C6, 0x01F3, 0x02A3]), // "dz"
  (&[0x64, 0x33], &[0x02A4]), // "d3"
  (&[0x74, 0x73], &[0x02A6]), // "ts"
  (&[0x74, 0x66], &[0x02A7]), // "tf"
  (&[0x74, 0x63], &[0x02A8]), // "tc"
  (&[0x66, 0x6E], &[0x02A9]), // "fn"
  (&[0x6C, 0x73], &[0x02AA]), // "ls"
  (&[0x6C, 0x7A], &[0x02AB]), // "lz"
  (&[0x6C, 0x6A], &[0x01C9]), // "lj"
  (&[0x6E, 0x6A], &[0x01CC]), // "nj"
  (&[0x66, 0x61, 0x78], &[0x213B]), // "fax"
  (&[0x3E], &[0x00BB, 0x02C3, 0x1433, 0x203A, 0x276F, 0xFE65, 0xFF1E]), // ">"
  (&[0x2B], &[0x00B1, 0x16ED, 0x207A, 0x208A, 0x2795, 0xFE62, 0xFF0B]), // "+"
  (&[0x2D], &[0x02D7, 0x06D4, 0x2010, 0x2011, 0x2012, 0x2043, 0x207B, 0x208B, 0x2796, 0x2CBB, 0xFE58, 0xFE63, 0xFF0D]), // "-"
  (&[0x3D], &[0x1400, 0x207C, 0x208C, 0x2E40, 0x30A0, 0xA4FF, 0xFE66, 0xFF1D]), // "="
  (&[0x28], &[0x207D, 0x208D, 0x2768, 0x2772, 0x3014, 0xFD3E, 0xFE59, 0xFE5D, 0xFF08, 0xFF5F]), // "("
  (&[0x29], &[0x207E, 0x208E, 0x2769, 0x2773, 0x29F4, 0x3015, 0xFD3F, 0xFE5A, 0xFE5E, 0xFF09, 0xFF60]), // ")"
  (&[0x21], &[0x00A1, 0x01C3, 0x2D51, 0xFE57, 0xFF01]), // "!"
  (&[0x22], &[0x201C, 0x201D, 0xFF02]), // "\""
  (&[0x23], &[0xFE5F, 0xFF03]), // "#"
  (&[0x24], &[0xFE69, 0xFF04]), // "$"
  (&[0x25], &[0xFE6A, 0xFF05]), // "%"
  (&[0x26], &[0x214B, 0xA778, 0xFE60, 0xFF06]), // "&"
  (&[0x27], &[0xFF07]), // "'"
  (&[0x2C], &[0x00B8, 0x060D, 0x066B, 0xA4F9, 0xFE50, 0xFF0C]), // ","
  (&[0x2E], &[0x0660, 0x06F0, 0x0701, 0x0702, 0x2024, 0xFE52, 0xFF0E]), // "."
  (&[0x2F], &[0x1735, 0x2041, 0x2044, 0x2215, 0x2571, 0x2CC7, 0x2F03, 0x3033, 0x30CE, 0x31D3, 0x4E3F, 0xFF0F]), // "/"
  (&[0x3A], &[0x02D0, 0x02F8, 0x0589, 0x05C3, 0x0703, 0x0704, 0x0903, 0x0A83, 0x16EC, 0x1803, 0x1809, 0x205A, 0x2236, 0xA4FD, 0xA789, 0xFE30, 0xFE55, 0xFF1A]), // ":"
  (&[0x3B], &[0xFE54, 0xFF1B]), // ";"
  (&[0x3C], &[0x00AB, 0x02C2, 0x1438, 0x16B2, 0x2039, 0x276E, 0xFE64, 0xFF1C]), // "<"
  (&[0x3F], &[0x00BF, 0x0242, 0x0294, 0x0295, 0x0296, 0x02A1, 0x02A2, 0x097D, 0xA6EB, 0xAB7E, 0xFE56, 0xFF1F]), // "?"
  (&[0x40], &[0xFE6B, 0xFF20]), // "@"
  (&[0x5B], &[0x3010, 0xFF3B]), // "["
  (&[0x5C], &[0x2216, 0x27CD, 0x29F5, 0x29F9, 0x2F02, 0x31D4, 0x4E36, 0xFE68, 0xFF3C]), // "\"
  (&[0x5D], &[0x3011, 0xFF3D]), // "]"
  (&[0x5E], &[0x02C4, 0x02C6, 0xFF3E]), // "^"
  (&[0x5F], &[0x07FA, 0xFE4D, 0xFE4E, 0xFE4F, 0xFF3F]), // "_"
  (&[0x60], &[0xFE51, 0xFF40]), // "`"
  (&[0x7B], &[0x2774, 0xFE5B, 0xFF5B]), // "{"
  (&[0x7C], &[0xFF5C]), // "|"
  (&[0x7D], &[0x2775, 0xFE5C, 0xFF5D]), // "}"
  (&[0x7E], &[0xFF5E]), // "~"
  (&[0x2A], &[0xA60E, 0xFE61]) // "*"
];

pub(crate) fn parse(parser: &mut Parser) -> bool {
  let byte = parser.get();
  
  for numeric in NUMERICAL {
    if byte >= numeric && byte <= (numeric + 9) {
      parser.push_byte(byte - numeric + 0x30);
      parser.advance(1);
      return true;
    }
  }
  
  for (key, value) in MISC {
    if value.contains(&byte) {
      for k in key {
        parser.push_byte(*k as u16);
      }
      
      parser.advance(1);
      return true;
    }
  }
  
  false
}